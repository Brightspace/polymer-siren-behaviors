<link rel="import" href="../../d2l-fetch/d2l-fetch.html">
<link rel="import" href="../../siren-parser-import/siren-parser.html">

<script type="module">
	import { EntityStore } from './redux-entity-store.js';
	import { fetchEntityIfNeeded } from './redux-entity-fetch.js';
	import { updateEntity } from './redux-entity-update.js';
	import { clearStore } from './redux-clear.js';
	import { parseLinkHeader } from './parse-link-header';

	window.D2L = window.D2L || {};
	window.D2L.Siren = window.D2L.Siren || {};

	window.D2L.Siren.EntityStore = {
		// This newer version of fetch uses d2l-fetch directly so we can set
		// appropriate headers to bypass caching done by the d2l-fetch middleware chain
		// The intention is to replace the fetch implementation that uses d2l-fetch-siren-entity-behavior with this
		// newer implementation.
		//
		// It is also now returning a promise so that the siren-action-behavior can co-ordinate
		// updating the UI more consistently when dependent entities change as a result of Siren
		// actions.
		fetch: function(entityId, token, bypassCache) {
			let unsubscribe;
			function subscription(resolve, reject) {
				const state = EntityStore.getState();
				const entitiesByToken = state.entitiesByHref[entityId];
				const entity = entitiesByToken && entitiesByToken[token];
				if (entity && !entity.isFetching) {
					if (entity.error) {
						reject(entity.error);
					} else {
						resolve(window.D2L.Hypermedia.Siren.Parse(entity.entity));
					}
					unsubscribe();
				}
			}

			const promise = new Promise((resolve, reject) => {
				unsubscribe = EntityStore.subscribe(() => subscription(resolve, reject));
				EntityStore.dispatch(fetchEntityIfNeeded(entityId, token, bypassCache))
					.catch(() => {})
					.then(() => subscription(resolve, reject));
			});
			return promise;
		},

		update: function(entityId, token, entity) {
			return EntityStore.dispatch(updateEntity(entityId, token, entity));
		},

		clear: function() {
			return EntityStore.dispatch(clearStore());
		},

		get: function(entityId, token) {
			return new Promise((resolve, reject) => {
				const state = EntityStore.getState();
				const entitiesByToken = state.entitiesByHref[entityId];
				const entity = entitiesByToken && entitiesByToken[token];
				if (entity && !entity.isFetching) {
					if (entity.error) {
						reject(entity.error);
					} else {
						resolve(window.D2L.Hypermedia.Siren.Parse(entity.entity));
					}
				} else {
					reject(new Error('Not fetched'));
				}
			});
		},

		// parse a Link header
		//
		// Link:<https://example.org/.meta>; rel=meta
		//
		// var r = parseLinkHeader(xhr.getResponseHeader('Link');
		// r['meta'] outputs https://example.org/.meta
		//
		parseLinkHeader: function(links) {
			return parseLinkHeader(links);
		}
	};
</script>
